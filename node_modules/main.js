import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';



let scene, camera, renderer, clock, controls;
let modeloFPS;
let crosshair;

init();
animate();

function init() {
  scene = new THREE.Scene();

  const Aloader = new THREE.TextureLoader();

  // Carregar texturas para cada face da caixa
  const textureFront = Aloader.load('/public/img/frente.jpeg');
  const textureBack = Aloader.load('/public/img/frente.jpeg');
  const textureTop = Aloader.load('/public/img/ceu.jpg');
  const textureBottom = Aloader.load('/public/img/frente.jpeg');
  const textureLeft = Aloader.load('/public/img/frente.jpeg');
  const textureRight = Aloader.load('/public/img/frente.jpeg');
  
  // Criar materiais para cada face, renderizando o lado interno
  const materialFront = new THREE.MeshBasicMaterial({ map: textureFront, side: THREE.BackSide });
  const materialBack = new THREE.MeshBasicMaterial({ map: textureBack, side: THREE.BackSide });
  const materialTop = new THREE.MeshBasicMaterial({ map: textureTop, side: THREE.BackSide });
  const materialBottom = new THREE.MeshBasicMaterial({ map: textureBottom, side: THREE.BackSide });
  const materialLeft = new THREE.MeshBasicMaterial({ map: textureLeft, side: THREE.BackSide });
  const materialRight = new THREE.MeshBasicMaterial({ map: textureRight, side: THREE.BackSide });
  
  // Array de materiais para cada face da caixa
  const materials = [
    materialFront,   // Frente
    materialBack,    // Trás
    materialTop,     // Topo
    materialBottom,  // Base
    materialLeft,    // Esquerda
    materialRight    // Direita
  ];
  
  // Criar a geometria da caixa
  const Ageometry = new THREE.BoxGeometry(200, 500, 300);
  
  // Criar a caixa com as texturas aplicadas nas faces internas
  const cube = new THREE.Mesh(Ageometry, materials);
  scene.add(cube);
  




  // Configura a câmera no estilo FPS
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1, 0);
  camera.rotation.order = 'YXZ'; // Posição em altura típica de FPS

  // Renderizador
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);


  // Relógio para animações
  clock = new THREE.Clock();


  // Adiciona luz à cena
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(51, 100, 7.5).normalize();
  scene.add(light);


  controls = new PointerLockControls(camera, document.body);

  const instructions = document.getElementById('oi');

  instructions.addEventListener('click', function () {
    controls.lock();
  });
  
  // Carrega o modelo GLB único (braço + arma)
  const loader = new GLTFLoader().setPath('/public/tactical_pistol/');

  // Carrega o modelo 3D
  loader.load('scene.gltf', (gltf) => {
    modeloFPS = gltf.scene;
    modeloFPS.position.set(2, -3, -9); // Ajuste a posição conforme necessário
    modeloFPS.rotation.set(0, Math.PI, 0);   // Rotaciona para ficar de frente
    camera.add(modeloFPS);

  }, undefined, function (error) {
    console.error('Ocorreu um erro ao carregar o modelo:', error);
  });


  // Adiciona uma mira simples no centro da tela
  const geometry = new THREE.RingGeometry(0.0, 0.015, 100);
  const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
  crosshair = new THREE.Mesh(geometry, material);
  crosshair.position.z = -2; // Posição da mira à frente da câmera

  camera.add(crosshair);
  scene.add(camera);

  // mmoviment odo mouse
  document.addEventListener('mousemove', onMouseMove, false);

}

function onMouseMove(event) {

}

function animate() {
  requestAnimationFrame(animate);

  // Animação da arma e mão (básico)
  const delta = clock.getDelta();
  if (modeloFPS) {
    // Movimento de respiração ou oscilação
    const t = clock.getElapsedTime();
    modeloFPS.position.y += Math.sin(t * 2) * 0.002;
  }

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
